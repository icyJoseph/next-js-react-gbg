<BlankLayout>

# Next.js

The React Framework for Production

</BlankLayout>

---

## Yet Another Framework?

> A JavaScript framework is created every X minutes

We should be critical of every dependency we use

<Note>
We are familiar with the joke, "a JavaScript framework is born every minute".

If you are a React Developer, there's a chance that you learned to use React through, Create React App (CRA).

In my case, I need to always know all the little details of how something works,
so I had initially started out with Webpack, in order to understand that my code,
written in modern JavaScript is compiled by Babel, and that it was bundled by Webpack.

However, once I found myself repeating the same configuration over and over,
I followed the crowd, and started to use Create React App.

</Note>

---

## Adoption Plan for React

- Building entire applications using React was the end goal

However, the adoption plan for React was to:

- Gradually transform your UI to use React, one part at a time
- This is why, React makes no assumptions about where it runs

<Note>
Let us remember that, there was a time when people were unsure about using 
Create React App for production applications.

Many saw CRA as an educational tool, and nothing more.

Let us **also** remember that, although, building entire applications
using React was the end goal, initially, the adoption plan for React was
to gradually transform parts of your UI to use React.

How should a production React App look like? Most people didn't know at the time.

Naturally, if you have spend time using Create React App,
your own Webpack, or whatever other means to use React,
seeing yet another one might be unsettling.

I've heard people before saying, why?, I already got something working for me,
or "pfft, ...a JavaScript framework is born every minute"

</Note>

---

## The paradox of choice

Next.js, Remix, Astro, CRA, Vite, Parcel, Gastby

> The fear or missing out

<Note>
If we think of React as the Linux Kernel, then,
CRA, your own Webpack, Parcel, Vite, Next.js, 
are all Distributions.

For Svelte for example, there's Svelte-Kit.

Still, why do we have so many?

Honestly, I don't really know, but I do see that
each aims at solving a particular issue, and whether
that issue is relevant anymore, is always up for debate.

</Note>

---

## Framework competition is good

The extreme progression in these type of production frameworks,
has lead to other languages getting involved:

- `esbuild` written in Go
- `SWC` written in Rust

---

## The problem we are trying to solve

- Ship a React App, properly bundled
- Keep Webpack under control
- Code React from the start
- Development Experience, focus on business code
- Use any styling solution we want
- Be fast, speed is good

---

## The value proposition

Next.js is a flexible React framework that gives you building blocks to create fast web applications.

By framework, we mean Next.js handles the tooling and configuration needed for React,
and provides additional structure, features, and optimizations for your application.

We could say it is a Full Stack Web SDK, based on React.

---

## The elevator pitch

> **Next.js** gives you the **best developer experience** with
> all the features you need for **production**:
>
> - Hybrid static and server rendering,
> - **TypeScript** support,
> - Smart bundling,
> - Route pre-fetching, and more.
>
> **No config needed.**

---

## Features

- The Next server
- `Server Side Rendering` (SSR), both at build and runtime
- `Incremental Static Regeneration` (ISR)
- Dynamic Routes
- API Routes
- Built in Router
- Server, Client bundle separation

<Note>
Learning to use Next.js, I think, 
is a good next step for front end developers,
because it is an intuitive way to learn 
to use Node.js on the back end, 
and to learn a full application stack, 
which is more valuable than just knowing how to use a framework.

It is a great first step into learning how to architect
an application beyond the views, and rather learn how
to deliver a value proposition end to end.

In this presentation I want to cover many topics,
for most I cannot do a full deep dive,
but I still want readers to know about as many as possible.

</Note>

---

## Even more features

- `_middleware`
- Full control over your SEO
- Static Site export, like `CRA`
- Magic Tags: `next/image`, and `next/script`
- `CSS-in-JS` solutions can render stylesheets on the server
- Owned by Vercel

---

## Server Side Rendering

### Challenges and pitfalls

- Isomorphic JavaScript
- No window
- JavaScript Contexts
- Memory Leaks
- Time to Visible and Time to Interactive
- Divergent HTML

These are not problems with Next.js, these are just challenges in the SSR world.

---

## Isomorphic JavaScript

> Also know as Universal JavaScript

The first frame rendered on the client, must match the frame rendered by the server.

This is basically a handover from Server to Client.

---

## Isomorphic JavaScript

- Server generates dry HTML (sync)
- Client hydrates the HTML (sync)
- React 18 improves how this is done

<Note>
The same code runs on the server, and on the client.

The Server generates the starter HTML, sends it to the client.
The Client in turn goes through a process called Hydration,
where instead of creating a DOM from zero,
the Client uses the starter HTML to attach event listeners.

React 18 has a game changing proposal on this regard

</Note>

---

## Isomorphic JavaScript

- SEO works without assumptions.
  - CSR SPA's depend on the Search Engine's to render the view
  - Open graph cards
- Works if JavaScript is disabled (for the most part)
- Time to visible performance
  - fewer roundtrips
  - fast servers
  - hot servers (caching)
  - faster data fetching
  - server and client work together

---

## No window

SSR happens on the server, without window or DOM elements

- Avoid initializing state based on window data
  - Use CSS to control responsive styles
- Avoid unguarded access to window or DOM elements
  - `typeof window !== 'undefined'`
- It is safe to access the window or DOM elements inside:
  - `useEffect`
  - Promises and event handlers (usually)

---

## No window

- [Next SSR isMobile control for component render](https://github.com/vercel/next.js/discussions/35392)
- [[SSR/OBS] SSR render components in wrong DOM place](https://github.com/vercel/next.js/discussions/35301)

<Card sx={{width: '80%', minWidth:'300px', maxWidth: '1580px', p: 0, mb:2 , '& > pre': { p: 1 }}}>

```ts
const isOBS = useMemo(
  () => (isBrowser ? navigator?.userAgent?.indexOf("OBS") !== -1 : false),
  [isBrowser]
);
```

</Card>

<Card sx={{width: '80%', minWidth:'300px', maxWidth: '1580px', p: 0, mb:2 , '& > pre': { p: 1 }}}>

```ts
const [isOBS, setIsOBS] = useState(false);

useEffect(() => {
  setIsOBS(isBrowser ? navigator?.userAgent?.indexOf("OBS") !== -1 : false);
}, [isBrowser]);
```

</Card>

---

## JavaScript Context

- Global variables are shared to all users making requests to your site
- Sharing data between server and client is through serialization
  - You cannot pass a class from the server to the client
  - You may accidentally serialize a Secrets
- Code that uses Node API's won't necessarily work on the client
- Functions shared between server and client
- `import { something } from '../my-lib'`

---

## Memory Leaks

- Server side memory leak
  - Might take several days/weeks to happen (usually on weekends)
  - Must restart the server
- A Browser memory leak
  - A really bad memory leak might be caught right away
  - Refresh the window (unless it's a really bad memory leak)

> [Memory leak #35526](https://github.com/vercel/next.js/discussions/35526)

<Note>
Another way to look at this: You deploy your Create React App,
and observe your error monitoring tool (which I hope you have set up),
and if you don't see anything wrong for a couple of hours, you call it a day.

When there's a server involved, it might take up to a
week before things start to go wrong.

Open connections, promises that are not resolved,
timers that keep on running, etc., are common memory leaks.

</Note>

---

## Time To Visible / Time To Interactive

- HTML is rendered on the server
  - Better Time To Visible metric
- Time To Interactive,
  - Doesn't improve much more
  - The client still has to prepare event listeners (hydration processe)
  - A visible UI, which doesn't respond, can frustrate users.

React 18 prepares mitigations.

<Note>
People don't generally click within the first second of page load.

React 18 aims to fix this by streaming HTML down to the client, and
prioritizing parts of the UI that the user wants to interact with.

The `getServerSideProps` method sort of breaks this rule, partially.

</Note>

---

## Divergent HTML

if **SSR HTML !== first CSR HTML** then **bugs will occur**.

> React warns about this

Happens when you rely on timing, randomness, or have unguarded access to the DOM that fails, but does not crash the SSR process.

If you can't design it away, hide those divergent parts behind client side activated flags.

<Note>

If the server side generated HTML, is not identical to
the client side HTML, bugs will occur.
React will warn you about this (with those warnings that are actually JavaScript Errors).

This can happen because you rely on timing, randomness,
or you have unguarded access to the DOM that fails, but does not crash the SSR process.

You have to design your site, so that this is not a problem.
Use placeholders, and combine hide those divergent parts
behind client side activated flags.

</Note>

---

## Divergent HTML

<Card sx={{width: '80%', minWidth:'300px', maxWidth: '1580px', p: 0, mb:2 , '& > pre': { p: 1 }}}>

```jsx
function Parent() {
  const [showChild, setShowChild] = useState(false);

  // Wait until after client-side hydration to show
  useEffect(() => {
    setShowChild(true);
  }, []);

  if (!showChild) {
    // You can show some kind of placeholder UI here
    return null;
  }

  return <Child {...props} />;
}
```

</Card>

---

## Divergent HTML

- [Both sides of ternary are rendered](https://github.com/vercel/next.js/discussions/34982)

<Card sx={{width: '80%', minWidth:'300px', maxWidth: '1580px', p: 0, mb:2 , '& > pre': { p: 1 }}}>

```jsx
return clientSecond === serverSecond ? (
  <div style={{ backgroundColor: "red" }}>RED</div>
) : (
  <div style={{ backgroundColor: "blue" }}>BLUE</div>
);
```

</Card>

> In practice it renders a RED div, with BLUE text!

---

## Success Story

### Wix.com

![Wix Time To Visible with SSR](./assets/wix_ttv_with_ssr.png)

<Note>
Like most things in life, it takes effort to get things right.

Accidental complexity creeps quickly, as you have access
to more tools and abilities. Consider the built in
complexity of your product, how can you actually
deliver your value proposition through SSR?

Unit tests, and Eslint, can help out with most of the above.

Proposed plugin, https://github.com/kopiro/eslint-plugin-ssr-friendly

You need to learn to use Node Inspect and
Diagnostics for performance measurement. https://nodejs.org/en/docs/guides/diagnostics-flamegraph/

</Note>

---

## Tool Box

- Anatomy of a `Next.js` project
- `_app` and `_document`
- Shared Layouts
- `next/router`
- Dynamic Routes
- API Routes
- Type of SSR
- Code Elimination
- `_middleware`
- `next.config.js`

---

<MDXPSideLayout showSlideNum={false} split={4}>

## New project

In the standard configuration, there's a couple of
`magic` folders:

- `public`
- `pages`
- `pages/api`

Or use a [boilerplate](https://github.com/ixartz/Next-js-Boilerplate)

<Card sx={{p: 0, '& > pre': { p: 1 }}}>

```bash
yarn create next-app --typescript
```

</Card>

<Card sx={{p: 0, '& > pre': { p: 1 }}}>

```shell
.
├── README.md
├── next-env.d.ts
├── next.config.js
├── node_modules
├── package.json
├── pages
│  ├── _app.tsx
│  ├── api
│  │  └── hello.ts
│  └── index.tsx
├── public
│  ├── favicon.ico
│  └── vercel.svg
├── styles
│  ├── Home.module.css
│  └── globals.css
├── tsconfig.json
└── yarn.lock
```

</Card>

</MDXPSideLayout>

---

<MDXPSideLayout showSlideNum={false} split={4}>

## File Structure

You can use `src` folder to group:

- `pages`
- `styles`
- `components`
- etc.

Config files must be at the root.

<Card sx={{p: 0, '& > pre': { p: 1 }}}>

```shell
.
├── README.md
├── next-env.d.ts
├── next.config.js
├── node_modules
├── package.json
├── public
│   ├── favicon.ico
│   └── vercel.svg
├── src
│   ├── pages
│   │   ├── _app.tsx
│   │   ├── api
│   │   │   └── hello.ts
│   │   └── index.tsx
│   └── styles
│       ├── Home.module.css
│       └── globals.css
├── tsconfig.json
└── yarn.lock
```

</Card>

</MDXPSideLayout>

---

<MDXPSideLayout showSlideNum={false} split={5}>

## Existing Project

Create a `pages` directory, and place
your routes inside it.

Add scripts to your `package.json` to do :

- `next dev`
- `next build`
- `next start`
- `next lint`

[Incremental adoption](https://nextjs.org/blog/incremental-adoption).

<Card sx={{p: 0, '& > pre': { p: 1 }}}>

```shell
yarn add next react react-dom --exact
yarn add --dev typescript @types/node @types/react --exact
touch tsconfig.json
```

</Card>

</MDXPSideLayout>

---

## `_app` and `_document`

---

## Shared Layout

---

## Dynamic Routes

---

## API Routes

---

## Types of SSR

- During Build Time: `next build`
- During Runtime: `next start`

Controlled from `/pages` level, based on what each page exports.

Automatic, `getStaticProps`, `getStaticPaths`, `getServerSideProps`.

> `getInitialProps` is no longer recommended

---

## Build Time SSR

Just export a component as default from a `page`, or you can fetch data for your pages, at build time, by using:

- `getStaticProps`
- `getStaticPaths`

---

## Runtime SSR

You can fetch data for your pages when the server is already deployed.

- On demand
  - `getServerSideProps`
- Incrementaly
  - `getStaticProps` and `getStaticPaths` with fallback

---

<MDXPSideLayout showSlideNum={false} split={4}>

## Automatic

Next.js calculates that a page like this,
can be rendered at build time.

The page can still use client side JavaScript to fetch
more data and update some of its elements.

`getInitialProps`, here or, in `_app`, disables this behavior.

<Card sx={{p: 0, '& > pre': { p: 1 }}}>

```tsx
// src/pages/index.tsx
import Head from "next/head";
import useSWR from "swr";

const Home = () => {
  const { data } = useSWR("some-data", fetcher);

  return (
    <>
      <Head>
        <title>Hello</title>
      </Head>

      <section>
        <p>Hello World!</p>
      </section>
    </>
  );
};

export default Home;
```

</Card>

</MDXPSideLayout>

---

<MDXPSideLayout showSlideNum={false} split={3}>

### `getStaticProps`

</MDXPSideLayout>

---

<MDXPSideLayout showSlideNum={false} split={3}>

### `getStaticPaths`

</MDXPSideLayout>

---

<MDXPSideLayout showSlideNum={false} split={3}>

### `getServerSideProps`

</MDXPSideLayout>

---

## [`next-code-elimination.vercel.app`](https://next-code-elimination.vercel.app/)

<iframe
  src="https://next-code-elimination.vercel.app/"
  style={{ width: "100%", height: "80%", maxWidth: "1580px" }}
/>

---

## `_middleware`

---

## `next.config.js`

<Card sx={{width: '80%', minWidth:'300px', maxWidth: '1580px', p: 0, '& > pre': { p: 1 }}}>

```js
/** @type {import('next').NextConfig} */
const nextConfig = {
  poweredByHeader: false,
  reactStrictMode: true,
  images: {
    domains: ["raw.githubusercontent.com"],
  },
  compiler: {
    styledComponents: true,
  },
  webpack(config, { isServer }) {
    return config;
  },
};

module.exports = nextConfig;
```

</Card>

---

## Client Side Escape Hatch

If you don't have a server, you can use `next export` to build a Static HTML Export,
which can be used as a standalone application, without a Node.js server.

---

## Env vars

- Load them from :
  - `.env.local` (overrides all)
  - `.env` (always used)
  - `.env.development` (overrides dev)
  - `.env.production` (overrides prod)
- `NEXT_PUBLIC_` env vars are available on the client
- Everything else is `undefined` on the client

---

## Left out

- Dynamic Imports
- Middleware for `api` routes (not `_middleware`)
- `next/image` and `next/script`
- Testing with `rtl`, `ts-mockito`, `MSW`, and friends.
- Authentication patterns
- MDX support
- 3rd party: `next-runtime`, `next-connect`
- React 18 and Server Components Preview
- Incremental Static Regeneration, on detail
- Using React Dev Tools
- Error Handling

---

## Demo Time

- Four pages
  - Landing
  - Single Pokémon
  - Pokémon Capture
  - Pokémon Collection
- API routes
  - Capture
  - Wild encounter

Uses `_middleware` to control `app-cookie`.

---

## Wrap up

- React is a means to an end
- Next.js builds on top of React's responsibility
- Data fetching, routing, API routes, and optimizations
- A good place to deploy, Vercel

<Note>
Throughout this document, I've almost not talked about 
React itself, and that's because as far as Next.js 
is concerned, React is a means to an end.

Next.js understands that React is really good at
its responsibility of rendering UI to the DOM.

From that starting point, Next.js builds data
fetching tools, server side lambdas, a solid router,
and the ability to optimize loading times as much as possible.

A good place to start deploying with Next.js apps is Vercel.

> There's other solutions out there, like Gastby,
> and Remix, however, I don't think doing a versus
> kind of talk is very productive.

A provoking thought to wrap up. With everything
I've showed you, does it ever make sense to compare
Angular to React anymore? Wouldn't it make more sense
to pit Angular against Next.js?

</Note>
